/**
 * Enhanced Telegram Service with ETHEREAL/TRANSCENDENT signal support
 */

import { formatEtherealTelegramMessage, type EtherealSignal } from "./ethereal-telegram-formatter"

// Standard signal interface
interface Signal {
  pair: string
  direction: "BUY" | "SELL"
  timeframe: string
  confidence: number
  timestamp: Date
  indicators?: Record<string, any>
  stopLoss?: number
  takeProfit?: number
}

export class TelegramService {
  private botToken: string
  private chatId: string
  private webhookUrl: string
  private isConnected = false

  constructor(botToken: string, chatId: string, webhookUrl: string) {
    this.botToken = botToken
    this.chatId = chatId
    this.webhookUrl = webhookUrl
  }

  /**
   * Sends a standard trading signal to Telegram
   */
  async sendSignal(signal: Signal): Promise<boolean> {
    const message = this.formatSignalMessage(signal)
    return this.sendMessage(message)
  }

  /**
   * Formats a standard signal message
   */
  private formatSignalMessage(signal: Signal): string {
    const directionEmoji = signal.direction === "BUY" ? "‚ñ≤" : "‚ñº"
    const directionColor = signal.direction === "BUY" ? "üü¢" : "üî¥"

    // Format the timestamp with Indonesian timezone (WIB)
    const formattedTime = signal.timestamp.toLocaleString("id-ID", {
      timeZone: "Asia/Jakarta",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    })

    return `ü§ñ TRADING SIGNAL ü§ñ

${directionColor} Pair: ${signal.pair}
‚è±Ô∏è Timeframe: ${signal.timeframe}
${directionColor} Signal: ${signal.direction} ${directionEmoji}
üéØ Confidence: ${(signal.confidence * 100).toFixed(2)}%
‚åõ Time: ${formattedTime} WIB

${signal.stopLoss ? `üõë Stop Loss: ${signal.stopLoss}` : ""}
${signal.takeProfit ? `üéØ Take Profit: ${signal.takeProfit}` : ""}

üìä Technical Indicators:
${this.formatIndicators(signal.indicators || {})}

ü§ñ Auto-generated by Pocket Option Trading System`
  }

  /**
   * Formats technical indicators for display
   */
  private formatIndicators(indicators: Record<string, any>): string {
    return Object.entries(indicators)
      .map(([key, value]) => `‚Ä¢ ${key}: ${value}`)
      .join("\n")
  }

  /**
   * Sends a message to Telegram
   */
  private async sendMessage(message: string): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          chat_id: this.chatId,
          text: message,
          parse_mode: "HTML",
        }),
      })

      const data = await response.json()
      return data.ok === true
    } catch (error) {
      console.error("Failed to send Telegram message:", error)
      return false
    }
  }

  /**
   * Sets up the Telegram webhook
   */
  async setupWebhook(): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/setWebhook`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          url: this.webhookUrl,
          allowed_updates: ["message"],
        }),
      })

      const data = await response.json()
      this.isConnected = data.ok === true
      return this.isConnected
    } catch (error) {
      console.error("Failed to set up Telegram webhook:", error)
      this.isConnected = false
      return false
    }
  }

  /**
   * Checks the webhook status
   */
  async checkWebhookStatus(): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/getWebhookInfo`)
      const data = await response.json()

      this.isConnected =
        data.ok === true &&
        data.result &&
        data.result.url === this.webhookUrl &&
        data.result.pending_update_count !== undefined

      return this.isConnected
    } catch (error) {
      console.error("Failed to check Telegram webhook status:", error)
      this.isConnected = false
      return false
    }
  }

  /**
   * Returns the connection status
   */
  isConnectedToTelegram(): boolean {
    return this.isConnected
  }

  // Add a new method to send ETHEREAL signals
  async sendEtherealSignal(signal: EtherealSignal): Promise<boolean> {
    if (!this.botToken || !this.chatId) {
      console.error("Telegram bot token or chat ID not configured")
      return false
    }

    try {
      const message = formatEtherealTelegramMessage(signal)

      // Send message without HTML parsing to avoid formatting issues
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          chat_id: this.chatId,
          text: message,
          // Remove parse_mode to send as plain text
        }),
      })

      const data = await response.json()
      if (!data.ok) {
        console.error("Failed to send ETHEREAL signal to Telegram:", data)
        return false
      }

      return true
    } catch (error) {
      console.error("Error sending ETHEREAL signal to Telegram:", error)
      return false
    }
  }
}

// Singleton instance
let telegramService: TelegramService | null = null

export function initTelegramService(botToken: string, chatId: string, webhookUrl: string): TelegramService {
  telegramService = new TelegramService(botToken, chatId, webhookUrl)
  return telegramService
}

export function getTelegramService(): TelegramService | null {
  return telegramService
}
