/**
 * Enhanced Telegram Service with ETHEREAL/TRANSCENDENT signal support
 */

import { formatEtherealTelegramMessage, type EtherealSignal } from "./ethereal-telegram-formatter"

// Standard signal interface
interface Signal {
  pair: string
  direction: "BUY" | "SELL"
  timeframe: string
  confidence: number
  timestamp: Date
  indicators?: Record<string, any>
  stopLoss?: number
  takeProfit?: number
}

export class TelegramService {
  private botToken: string
  private chatId: string
  private webhookUrl: string
  private isConnected = false

  constructor(botToken: string, chatId: string, webhookUrl: string) {
    this.botToken = botToken
    this.chatId = chatId
    this.webhookUrl = webhookUrl
  }

  /**
   * Sends a standard trading signal to Telegram
   */
  async sendSignal(signal: Signal): Promise<boolean> {
    const message = this.formatSignalMessage(signal)
    return this.sendMessage(message)
  }

  /**
   * Formats a standard signal message
   */
  private formatSignalMessage(signal: Signal): string {
    const directionEmoji = signal.direction === "BUY" ? "â–²" : "â–¼"
    const directionColor = signal.direction === "BUY" ? "ðŸŸ¢" : "ðŸ”´"
    const directionText = signal.direction === "BUY" ? "BUY" : "SELL"

    // Format the timestamp with Indonesian timezone (WIB)
    const formattedTime = signal.timestamp.toLocaleString("id-ID", {
      timeZone: "Asia/Jakarta",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    })

    // Get indicator values
    const indicators = signal.indicators || {}
    const rsi = indicators.rsi !== undefined ? indicators.rsi.toFixed(2) : "N/A"
    const macd = indicators.macd !== undefined ? indicators.macd.toFixed(5) : "N/A"
    const ema = indicators.ema !== undefined ? indicators.ema.toFixed(5) : "N/A"
    const volatility = indicators.volatility || "Average"
    const assetStrength = indicators.assetStrength || "Neutral"
    const volumeResult = indicators.volumeResult || "Normal"
    const sentiment = indicators.sentiment || "Neutral"
    const price = indicators.price !== undefined ? indicators.price.toFixed(5) : "N/A"
    const resistance = indicators.resistance !== undefined ? indicators.resistance.toFixed(5) : "N/A"
    const support = indicators.support !== undefined ? indicators.support.toFixed(5) : "N/A"
    const strength = indicators.strength !== undefined ? `${indicators.strength}/100` : "N/A"
    const marketConditions = indicators.marketConditions || "Normal"

    // New format as requested
    return `${signal.pair} | ${signal.timeframe} | ${directionText.toLowerCase()}

ðŸ“¡ Market info:
â€¢ Volatility: ${volatility}
â€¢ Asset strength by volume: ${assetStrength}
â€¢ Volume result: ${volumeResult}
â€¢ Sentiment: ${sentiment}

ðŸ’µ Technical overview:
â€¢ Current price: ${price}
â€¢ Resistance (R1): ${resistance}
â€¢ Support (S1): ${support}
â€¢ RSI: ${rsi}
â€¢ MACD: ${macd}
â€¢ Moving Average: ${ema}

ðŸ“‡ Signal strength:
â€¢ Strength: ${strength}
â€¢ Market conditions: ${marketConditions}

âŒ› Time: ${formattedTime} WIB

${signal.stopLoss ? `ðŸ›‘ Stop Loss: ${signal.stopLoss}` : ""}
${signal.takeProfit ? `ðŸŽ¯ Take Profit: ${signal.takeProfit}` : ""}

ðŸ¤– Auto-generated by Pocket Option Trading System`
  }

  /**
   * Formats technical indicators for display
   */
  private formatIndicators(indicators: Record<string, any>): string {
    return Object.entries(indicators)
      .map(([key, value]) => `â€¢ ${key}: ${value}`)
      .join("\n")
  }

  /**
   * Sends a message to Telegram
   */
  private async sendMessage(message: string): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          chat_id: this.chatId,
          text: message,
          parse_mode: "HTML",
        }),
      })

      const data = await response.json()
      return data.ok === true
    } catch (error) {
      console.error("Failed to send Telegram message:", error)
      return false
    }
  }

  /**
   * Sets up the Telegram webhook
   */
  async setupWebhook(): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/setWebhook`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          url: this.webhookUrl,
          allowed_updates: ["message"],
        }),
      })

      const data = await response.json()
      this.isConnected = data.ok === true
      return this.isConnected
    } catch (error) {
      console.error("Failed to set up Telegram webhook:", error)
      this.isConnected = false
      return false
    }
  }

  /**
   * Checks the webhook status
   */
  async checkWebhookStatus(): Promise<boolean> {
    try {
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/getWebhookInfo`)
      const data = await response.json()

      this.isConnected =
        data.ok === true &&
        data.result &&
        data.result.url === this.webhookUrl &&
        data.result.pending_update_count !== undefined

      return this.isConnected
    } catch (error) {
      console.error("Failed to check Telegram webhook status:", error)
      this.isConnected = false
      return false
    }
  }

  /**
   * Returns the connection status
   */
  isConnectedToTelegram(): boolean {
    return this.isConnected
  }

  // Add a new method to send ETHEREAL signals
  async sendEtherealSignal(signal: EtherealSignal): Promise<boolean> {
    if (!this.botToken || !this.chatId) {
      console.error("Telegram bot token or chat ID not configured")
      return false
    }

    try {
      const message = formatEtherealTelegramMessage(signal)

      // Send message without HTML parsing to avoid formatting issues
      const response = await fetch(`https://api.telegram.org/bot${this.botToken}/sendMessage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          chat_id: this.chatId,
          text: message,
          // Remove parse_mode to send as plain text
        }),
      })

      const data = await response.json()
      if (!data.ok) {
        console.error("Failed to send ETHEREAL signal to Telegram:", data)
        return false
      }

      return true
    } catch (error) {
      console.error("Error sending ETHEREAL signal to Telegram:", error)
      return false
    }
  }
}

// Singleton instance
let telegramService: TelegramService | null = null

export function initTelegramService(botToken: string, chatId: string, webhookUrl: string): TelegramService {
  telegramService = new TelegramService(botToken, chatId, webhookUrl)
  return telegramService
}

export function getTelegramService(): TelegramService | null {
  return telegramService
}
